# 3D Animations Documentation

This document covers 3D animation development using `@remotion/three` with React Three Fiber.

## Overview

The project supports 3D animations through Remotion's integration with React Three Fiber. This enables complex 3D scenes, animations, and effects.

## Prerequisites

### Dependencies

```json
{
  "dependencies": {
    "@remotion/three": "^4.0.138",
    "three": "^0.160.0",
    "@react-three/fiber": "^8.15.0",
    "@react-three/drei": "^9.92.0"
  }
}
```

### Installation

```bash
npm install @remotion/three three @react-three/fiber @react-three/drei
```

## Basic 3D Composition

### Simple 3D Scene

```tsx
import React, { useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { CubeCamera, Environment } from '@react-three/drei'
import { CompositionProps } from '@remotion-mp4/core'

interface RotatingCubeProps extends CompositionProps {
  color?: string
  speed?: number
}

export const RotatingCube: React.FC<RotatingCubeProps> = ({ color = '#3498db', speed = 1 }) => {
  const meshRef = useRef<THREE.Mesh>(null)

  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.x += delta * speed
      meshRef.current.rotation.y += delta * speed * 0.5
    }
  })

  return (
    <Canvas>
      <color attach="background" args={['#1a1a2e']} />
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} />

      <mesh ref={meshRef}>
        <boxGeometry args={[2, 2, 2]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </Canvas>
  )
}
```

### Props Schema

```tsx
import { z } from 'zod'

export const RotatingCubeProps = z.object({
  color: z.string().default('#3498db'),
  speed: z.number().min(0).max(10).default(1),
})

export type RotatingCubeProps = z.infer<typeof RotatingCubeProps>
```

### Registration

```tsx
export function registerRotatingCube() {
  return {
    id: 'RotatingCube',
    component: RotatingCube,
    propsSchema: RotatingCubeProps,
    defaultProps: {
      color: '#3498db',
      speed: 1,
    },
    width: 1920,
    height: 1080,
    fps: 30,
    durationInFrames: 180, // 6 seconds at 30fps
  }
}
```

## 3D Animation Patterns

### Animated Properties

Use `useFrame()` for frame-by-frame animation:

```tsx
import { useFrame } from '@react-three/fiber'
import { useSpring, animated } from '@react-spring/three'

// Option 1: Direct frame manipulation
export const AnimatedBox: React.FC = () => {
  const meshRef = useRef<THREE.Mesh>(null)

  useFrame((state) => {
    if (meshRef.current) {
      // Animate based on frame
      const t = state.clock.getElapsedTime()
      meshRef.current.position.y = Math.sin(t) * 2
    }
  })

  return (
    <mesh ref={meshRef}>
      <boxGeometry />
      <meshStandardMaterial color="hotpink" />
    </mesh>
  )
}

// Option 2: React Spring (smoother)
export const SpringBox: React.FC = () => {
  const [active, setActive] = useState(false)
  const { scale } = useSpring({
    scale: active ? 2 : 1,
    config: config.wobbly,
  })

  return (
    <animated.mesh scale={scale} onClick={() => setActive(!active)}>
      <boxGeometry />
      <meshStandardMaterial color="orange" />
    </animated.mesh>
  )
}
```

### Camera Movement

```tsx
import { PerspectiveCamera, useFrame } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'

export const MovingCamera: React.FC = () => {
  const cameraRef = useRef<THREE.PerspectiveCamera>(null)

  useFrame((state) => {
    if (cameraRef.current) {
      // Orbit camera around center
      const t = state.clock.getElapsedTime()
      cameraRef.current.position.x = Math.sin(t) * 10
      cameraRef.current.position.z = Math.cos(t) * 10
      cameraRef.current.lookAt(0, 0, 0)
    }
  })

  return (
    <>
      <PerspectiveCamera ref={cameraRef} makeDefault position={[0, 5, 10]} fov={75} />
      <OrbitControls />
    </>
  )
}
```

### Lighting Setup

```tsx
export const LightingScene: React.FC = () => {
  return (
    <>
      {/* Ambient - base illumination */}
      <ambientLight intensity={0.3} />

      {/* Directional - sun-like */}
      <directionalLight position={[5, 10, 5]} intensity={1} castShadow />

      {/* Point - local light source */}
      <pointLight position={[-5, 5, -5]} intensity={0.5} color="blue" />

      {/* Spot - focused beam */}
      <spotLight position={[0, 10, 0]} angle={0.3} penumbra={1} intensity={1} castShadow />

      {/* Environment map */}
      <Environment preset="sunset" />
    </>
  )
}
```

### Materials

```tsx
import { MeshStandardMaterial, MeshPhysicalMaterial } from 'three'

export const MaterialExamples: React.FC = () => {
  return (
    <>
      {/* Standard - reacts to light */}
      <mesh>
        <boxGeometry />
        <meshStandardMaterial color="red" metalness={0.5} roughness={0.5} />
      </mesh>

      {/* Physical - more realistic */}
      <mesh position={[2, 0, 0]}>
        <sphereGeometry args={[1, 32, 32]} />
        <meshPhysicalMaterial
          color="white"
          metalness={0}
          roughness={0.1}
          clearcoat={1}
          clearcoatRoughness={0.1}
        />
      </mesh>

      {/* Toon - cel-shaded */}
      <mesh position={[-2, 0, 0]}>
        <torusKnotGeometry args={[0.8, 0.3, 100, 16]} />
        <meshToonMaterial color="purple" />
      </mesh>
    </>
  )
}
```

## Text in 3D

```tsx
import { Text } from '@react-three/drei'

export const Text3D: React.FC<{ text: string }> = ({ text }) => {
  return (
    <Text
      font="/fonts/inter-bold.woff" // Path to font file
      fontSize={2}
      color="white"
      anchorX="center"
      anchorY="middle"
      position={[0, 0, 0]}
    >
      {text}
    </Text>
  )
}
```

## Particle Systems

```tsx
import { Points, PointMaterial } from '@react-three/drei'
import * as random from 'maath/random/dist/maath-random.esm'

export const Particles: React.FC<{ count: number }> = ({ count = 1000 }) => {
  // Generate random points in a sphere
  const positions = new Float32Array(count * 3)
  random.inSphere(positions, { radius: 5 })

  useFrame((state) => {
    // Slowly rotate particles
    const t = state.clock.getElapsedTime()
    // Custom animation logic here
  })

  return (
    <Points positions={positions} stride={3} frustumCulled={false}>
      <PointMaterial
        transparent
        color="#3498db"
        size={0.1}
        sizeAttenuation={true}
        depthWrite={false}
      />
    </Points>
  )
}
```

## Post-Processing

```tsx
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing'

export const EffectsScene: React.FC = () => {
  return (
    <>
      <mesh>
        <sphereGeometry args={[1, 32, 32]} />
        <meshStandardMaterial color="hotpink" emissive="hotpink" emissiveIntensity={2} />
      </mesh>

      <EffectComposer>
        <Bloom luminanceThreshold={1} luminanceSmoothing={0.9} height={300} intensity={1.5} />
        <Vignette eskil={false} offset={0.1} darkness={0.5} />
      </EffectComposer>
    </>
  )
}
```

## WebGL Mode Selection

### Required for 3D

3D compositions **require** WebGL mode:

```bash
# Software rendering (works everywhere)
npm run render -- --comp RotatingCube --out out.mp4 --gl swangle

# Hardware acceleration (faster)
npm run render -- --comp RotatingCube --out out.mp4 --gl angle

# CPU-only rendering
npm run render -- --comp RotatingCube --out out.mp4 --gl swiftshader
```

### Mode Compatibility

| Platform | Default | Hardware        | Software             |
| -------- | ------- | --------------- | -------------------- |
| Windows  | angle   | angle, directx9 | swangle, swiftshader |
| macOS    | angle   | angle           | swangle, swiftshader |
| Linux    | angle   | angle, egl      | swangle, swiftshader |

## Performance Optimization

### Reducing Draw Calls

```tsx
// ❌ Multiple meshes - many draw calls
export const BadExample: React.FC = () => {
  return (
    <>
      {Array(100)
        .fill(0)
        .map((_, i) => (
          <mesh key={i} position={[i, 0, 0]}>
            <boxGeometry />
            <meshStandardMaterial />
          </mesh>
        ))}
    </>
  )
}

// ✅ Instanced mesh - single draw call
export const GoodExample: React.FC = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null)
  const count = 100
  const tempObject = new THREE.Object3D()

  useEffect(() => {
    for (let i = 0; i < count; i++) {
      tempObject.position.set(i, 0, 0)
      tempObject.updateMatrix()
      meshRef.current!.setMatrixAt(i, tempObject.matrix)
    }
    meshRef.current.instanceMatrix.needsUpdate = true
  }, [])

  return (
    <instancedMesh ref={meshRef} args={[undefined, undefined, count]}>
      <boxGeometry />
      <meshStandardMaterial />
    </instancedMesh>
  )
}
```

### Lazy Loading

```tsx
import { Suspense, lazy } from 'react'

// Lazy load heavy 3D models
const HeavyModel = lazy(() => import('./HeavyModel'))

export const SceneWithLazyModel: React.FC = () => {
  return (
    <Canvas>
      <Suspense fallback={<LoadingSpinner />}>
        <HeavyModel />
      </Suspense>
    </Canvas>
  )
}
```

### Geometry Simplification

```tsx
// High detail (slow)
<mesh>
  <sphereGeometry args={[1, 64, 64]} />  // Many polygons
</mesh>

// Lower detail (faster)
<mesh>
  <sphereGeometry args={[1, 16, 16]} />  // Fewer polygons
</mesh>
```

## Common Issues

### Issue: "WebGL not available"

**Cause**: Forgot `--gl` flag for 3D rendering.

**Solution**:

```bash
npm run render -- --comp My3DAnim --out out.mp4 --gl swangle
```

### Issue: Black screen

**Cause**: Missing lights or camera position.

**Solution**:

```tsx
<Canvas>
  {/* Camera */}
  <perspectiveCamera position={[0, 0, 5]} />

  {/* Lights */}
  <ambientLight intensity={0.5} />
  <pointLight position={[10, 10, 10]} />

  {/* Your mesh */}
  <mesh>
    <boxGeometry />
    <meshStandardMaterial />
  </mesh>
</Canvas>
```

### Issue: Flickering

**Cause**: Frame rate mismatch or memory issues.

**Solution**:

```bash
# Reduce FPS
npm run render -- --comp My3DAnim --out out.mp4 --fps 24

# Or simplify scene
```

### Issue: Memory leak

**Cause**: Not disposing geometries/materials.

**Solution**:

```tsx
import { useMemo } from 'react'

export const MemorySafeMesh: React.FC = () => {
  // Reuse geometry
  const geometry = useMemo(() => {
    return new THREE.BoxGeometry(1, 1, 1)
  }, [])

  // Manual cleanup
  useEffect(() => {
    return () => {
      geometry.dispose()
    }
  }, [geometry])

  return (
    <mesh geometry={geometry}>
      <meshStandardMaterial />
    </mesh>
  )
}
```

## Best Practices

1. **Use `useFrame` sparingly**: Only update what's animating
2. **Reuse geometries**: Create once, use multiple times
3. **Simplify geometry**: Lower polygon counts when possible
4. **Bake animations**: Pre-compute when possible
5. **Use instancing**: For many identical objects
6. **Profile**: Use Chrome DevTools performance tab
7. **Test render**: Render at low FPS first
8. **Clear cache**: Between renders if memory issues

## Examples

### Rotating Cube with Color Change

```tsx
export const ColorChangingCube: React.FC = () => {
  const meshRef = useRef<THREE.Mesh>(null)
  const frame = useCurrentFrame()

  useFrame(() => {
    if (meshRef.current) {
      meshRef.current.rotation.x += 0.01
      meshRef.current.rotation.y += 0.01

      // Color change over time
      const hue = (frame / 60) % 1
      ;(meshRef.current.material as THREE.MeshStandardMaterial).color.setHSL(hue, 0.5, 0.5)
    }
  })

  return (
    <mesh ref={meshRef}>
      <boxGeometry args={[2, 2, 2]} />
      <meshStandardMaterial />
    </mesh>
  )
}
```

### Interactive 3D Scene

```tsx
export const InteractiveScene: React.FC = () => {
  const [hovered, setHovered] = useState(false)
  const [active, setActive] = useState(false)

  return (
    <>
      <mesh
        onPointerOver={() => setHovered(true)}
        onPointerOut={() => setHovered(false)}
        onClick={() => setActive(!active)}
        scale={active ? 1.5 : 1}
      >
        <icosahedronGeometry args={[1, 0]} />
        <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} wireframe={hovered} />
      </mesh>
    </>
  )
}
```
